name: Claude Code

on:
  issue_comment:
    types: [created]
  pull_request_review_comment:
    types: [created]
  issues:
    types: [opened, assigned, labeled]
  pull_request_review:
    types: [submitted]
  pull_request:
    types: [opened, synchronize]

jobs:
  claude:
    if: |
      (github.event_name == 'issue_comment' && contains(github.event.comment.body, '@claude')) ||
      (github.event_name == 'pull_request_review_comment' && contains(github.event.comment.body, '@claude')) ||
      (github.event_name == 'pull_request_review' && contains(github.event.review.body, '@claude')) ||
      (github.event_name == 'issues' && (contains(github.event.issue.body, '@claude') || contains(github.event.issue.title, '@claude'))) ||
      (github.event_name == 'pull_request' && github.event.pull_request.draft == false)
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
      id-token: write
      actions: read
      deployments: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Wait for Vercel deployment and extract URL
      - name: Wait for Vercel Deployment
        id: deployment
        uses: actions/github-script@v6
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            let pr_number;
            let head_sha;

            // Determine PR number and head SHA based on event type
            if (context.eventName === 'pull_request') {
              pr_number = context.payload.pull_request.number;
              head_sha = context.payload.pull_request.head.sha;
            } else if (context.eventName === 'issue_comment' && context.payload.issue.pull_request) {
              pr_number = context.payload.issue.number;
              // Get PR details to find head SHA
              const { data: pr } = await github.rest.pulls.get({
                owner,
                repo,
                pull_number: pr_number
              });
              head_sha = pr.head.sha;
            } else if (context.eventName === 'pull_request_review') {
              pr_number = context.payload.pull_request.number;
              head_sha = context.payload.pull_request.head.sha;
            } else if (context.eventName === 'pull_request_review_comment') {
              pr_number = context.payload.pull_request.number;
              head_sha = context.payload.pull_request.head.sha;
            }

            if (!pr_number) {
              console.log('No PR number found, skipping deployment wait');
              core.setOutput('deployment_ready', 'false');
              return;
            }

            console.log(`Checking Vercel deployment for PR #${pr_number}, SHA: ${head_sha}`);
            core.setOutput('pr_number', pr_number);

            // Wait for Vercel deployment (max 10 minutes)
            let deploymentUrl = '';
            let attempts = 0;
            const maxAttempts = 60; // 60 * 10 seconds = 10 minutes

            while (attempts < maxAttempts && !deploymentUrl) {
              attempts++;

              // Check deployments API for Vercel deployment
              try {
                const { data: deployments } = await github.rest.repos.listDeployments({
                  owner,
                  repo,
                  sha: head_sha,
                  environment: 'Preview',
                  per_page: 5
                });

                for (const deployment of deployments) {
                  const { data: statuses } = await github.rest.repos.listDeploymentStatuses({
                    owner,
                    repo,
                    deployment_id: deployment.id,
                    per_page: 1
                  });

                  if (statuses.length > 0 && statuses[0].state === 'success') {
                    deploymentUrl = statuses[0].environment_url || statuses[0].target_url;
                    if (deploymentUrl) {
                      console.log(`Found Vercel deployment URL: ${deploymentUrl}`);
                      break;
                    }
                  }
                }
              } catch (e) {
                console.log(`Deployment API check failed: ${e.message}`);
              }

              // Fallback: Check PR comments for Vercel bot comment
              if (!deploymentUrl) {
                const { data: comments } = await github.rest.issues.listComments({
                  owner,
                  repo,
                  issue_number: pr_number
                });

                const vercelComment = comments.find(comment =>
                  (comment.user.login === 'vercel[bot]' || comment.user.login === 'vercel') &&
                  comment.body.includes('vercel.app')
                );

                if (vercelComment) {
                  // Extract Preview URL from Vercel comment
                  const urlMatch = vercelComment.body.match(/https:\/\/[a-z0-9-]+\.vercel\.app/i);
                  if (urlMatch) {
                    deploymentUrl = urlMatch[0];
                    console.log(`Found Vercel URL from comment: ${deploymentUrl}`);
                  }
                }
              }

              if (deploymentUrl) break;

              console.log(`Waiting for Vercel deployment... (attempt ${attempts}/${maxAttempts})`);
              await new Promise(resolve => setTimeout(resolve, 10000)); // Wait 10 seconds
            }

            if (deploymentUrl) {
              core.setOutput('deployment_url', deploymentUrl);

              // Health check - wait for the deployment to be ready
              console.log('Performing health check...');
              let healthy = false;
              for (let i = 0; i < 12; i++) {
                try {
                  const response = await fetch(deploymentUrl, {
                    method: 'HEAD',
                    redirect: 'follow'
                  });
                  if (response.ok || response.status === 308) {
                    console.log('✅ Vercel deployment is ready');
                    healthy = true;
                    break;
                  }
                } catch (e) {
                  console.log(`Health check attempt ${i + 1} failed: ${e.message}`);
                }
                await new Promise(resolve => setTimeout(resolve, 5000));
              }
              core.setOutput('deployment_ready', healthy ? 'true' : 'false');
            } else {
              console.log('⚠️ No Vercel deployment URL found');
              core.setOutput('deployment_ready', 'false');
            }

      - name: Generate GitHub App token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Run Claude Code
        uses: anthropics/claude-code-action@beta
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          github_token: ${{ steps.app-token.outputs.token }}

          # Tool permissions for frontend development
          allowed_tools: |
            Bash(curl:*),
            Bash(pnpm:*),
            Bash(npx:*),
            Bash(node:*),
            Bash(git:*),
            Bash(jest:*),
            Bash(biome:*),
            Bash(tsc:*),
            Bash(playwright:*),
            Bash(cypress:*),
            Bash(lighthouse:*),
            Edit,
            MultiEdit,
            Read,
            Write,
            NotebookEditCell,
            mcp__sequential-thinking__sequentialthinking,
            mcp__filesystem__*,
            mcp__fetch__*

          # Environment variables
          claude_env: |
            NODE_ENV: test
            PREVIEW_URL: ${{ steps.deployment.outputs.deployment_url || '' }}
            PR_NUMBER: ${{ steps.deployment.outputs.pr_number || github.event.pull_request.number || '' }}
            DEPLOYMENT_READY: ${{ steps.deployment.outputs.deployment_ready || 'false' }}
            NEXT_PUBLIC_PRIVY_APP_ID: ${{ secrets.NEXT_PUBLIC_PRIVY_APP_ID || 'test-app-id' }}
            CI: true

          # MCP servers configuration
          mcp_config: |
            {
              "mcpServers": {
                "sequential-thinking": {
                  "command": "npx",
                  "args": ["-y", "@modelcontextprotocol/server-sequential-thinking"]
                },
                "filesystem": {
                  "command": "npx",
                  "args": ["-y", "@modelcontextprotocol/server-filesystem", "/tmp"]
                },
                "fetch": {
                  "command": "npx",
                  "args": ["-y", "@modelcontextprotocol/server-fetch"],
                  "env": {
                    "ALLOWED_DOMAINS": "${{ steps.deployment.outputs.deployment_url && format('{0},api.github.com', steps.deployment.outputs.deployment_url) || 'localhost,api.github.com' }}"
                  }
                }
              }
            }

          # Custom instructions for frontend code review
          custom_instructions: |
            ## Project: gap-app-v2
            Next.js 15 (App Router, Turbopack) | React 19 | TypeScript | TailwindCSS + Tremor | Zustand | React Query | Wagmi/RainbowKit | Radix UI | Biome

            Preview URL: ${{ steps.deployment.outputs.deployment_url || 'Not available' }}

            Also read and enforce the CLAUDE.md in this repo for project-specific anti-patterns.

            ## Review Rules

            **OUTPUT FORMAT**: Only report problems. Do NOT list strengths, compliments, or "what looks good". If a file has no issues, skip it entirely. If the entire PR has no issues, say "No issues found." and nothing else.

            **TRIAGE ORDER**: Review in this priority: security/bugs first, then performance, then architecture, then everything else. Report issues grouped by file.

            **STRUCTURE**: For each issue found, use this format:
            - **File**: `path/to/file.ts:LINE`
            - **Rule**: [rule identifier]
            - **Severity**: CRITICAL | HIGH | MEDIUM
            - **Problem**: One sentence describing what is wrong.
            - **Why**: Root cause or why this matters (one sentence).
            - **Fix**: Concrete code snippet or one-sentence fix.

            Only report MEDIUM severity and above. Skip nitpicks.

            **AI SLOP DETECTION**: Flag AI-generated code smells: nonsensical comments that describe the obvious, copy-pasted boilerplate that does not fit the context, dead code left behind, overly verbose abstractions for trivial operations, hallucinated API usage.

            **END WITH**: A single line: "Recommendation: APPROVE" or "Recommendation: BLOCK (reason)". BLOCK only for CRITICAL issues. Nothing else after this line.

            ---

            ### 1. Waterfall and Async (CRITICAL)
            - Sequential await calls that could run in parallel: use Promise.all()
            - Awaiting values only used in one branch: move await into that branch
            - Missing Suspense boundaries for streaming async content
            - API routes that await early instead of starting promises early and awaiting late

            ### 2. Bundle Size (CRITICAL)
            - Barrel file imports (import from index files): import from source file directly
            - Heavy components not using next/dynamic for lazy loading
            - Third-party scripts (analytics, logging) not deferred until after hydration
            - Modules loaded unconditionally that are only used behind feature flags: use dynamic import

            ### 3. Server vs Client Components (HIGH)
            - "use client" on components that do not use hooks, event handlers, or browser APIs: make them Server Components
            - Data fetching in Client Components that should happen server-side
            - Large objects passed from Server to Client components: minimize serialization
            - Missing React.cache() for per-request deduplication in Server Components
            - Sequential server fetches that should be parallelized by restructuring component tree

            ### 4. Component Architecture (HIGH)
            - Boolean prop proliferation (isX, showY, hasZ): use composition with compound components or explicit variants
            - Monolithic components with render props: prefer children-based compound components
            - State trapped inside components that siblings need: lift state into provider
            - Missing generic context interfaces (state/actions/meta pattern) for dependency injection
            - Components doing too many things: split into explicit named variants (e.g., ThreadComposer, EditComposer)
            - React 19: still using forwardRef when ref is now a regular prop
            - React 19: still using useContext() when use() is available

            ### 5. TypeScript (HIGH)
            - any type without explicit justification comment
            - Missing or incomplete prop type definitions
            - Type assertions (as) that could be replaced with type guards
            - Unused type imports or exports

            ### 6. Re-render and Performance (MEDIUM)
            - Components subscribing to store state only used in callbacks: use useStore.getState() instead
            - Missing React.memo on expensive components that receive stable props from parent
            - Object/array dependencies in useEffect/useMemo: use primitive values or stable references
            - Subscribing to full objects when only a boolean derived value is needed
            - Inline object/function creation in JSX causing child re-renders
            - Missing next/image for images
            - Using && for conditional rendering (can render 0 or empty string): use ternary

            ### 7. State Management (MEDIUM)
            - Zustand store with too many concerns: split stores by domain
            - React Query missing proper staleTime / gcTime configuration
            - Missing loading/error/empty states in data-dependent UI
            - Optimistic updates without rollback on error

            ### 8. Web3 (MEDIUM)
            - Wagmi hooks used without proper error handling for rejected transactions
            - Missing wallet disconnection handling
            - Hardcoded chain IDs or contract addresses: use constants

            ### 9. Accessibility (MEDIUM)
            - Interactive elements missing ARIA labels or roles
            - Missing keyboard navigation for custom interactive components
            - Non-semantic HTML (div with onClick instead of button)
            - Missing focus management on modals/dialogs

            ### 10. Testing (MEDIUM)
            - New functionality without corresponding tests (target: 70% coverage)
            - Bug fixes without regression tests
            - Tests that test implementation details instead of behavior

            ---

            ## Event-Specific Behavior

            **New PRs**: Review all changed files against the rules above. Only output issues.
            **@claude comments**: Answer the specific question or request directly.
            **Review comments**: Analyze the specific code referenced and respond.

          # Conditional prompts based on triggers - enables automatic PR reviews
          direct_prompt: |
            ${{ github.event_name == 'pull_request' && 'Review this PR against the rules in custom_instructions. Triage: security/bugs first, then performance, then architecture. Only report MEDIUM+ issues. For each: file:line, rule, severity, problem, root cause, fix. Flag any AI-generated slop. End with "Recommendation: APPROVE" or "Recommendation: BLOCK (reason)". No strengths, no praise. If clean, say "No issues found." then "Recommendation: APPROVE".' || '' }}

          max_turns: '30'
          timeout_minutes: '45'

